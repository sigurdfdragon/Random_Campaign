#textdomain wesnoth-Random_Campaign

# SETUP SCENARIO MACROS

#define RC_ENEMY_SIDE_START SIDE VILLAGE_GOLD
    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        hidden=yes
        team_name=2
        fog=no
        shroud=no
        gold=175
        village_gold={VILLAGE_GOLD}
    [/side]
#enddef

#define RC_PLAYER_SIDE_START SIDE VILLAGE_GOLD COLOR_LOCK
    [side]
        side={SIDE}
        save_id="P{SIDE}"
        persistent=yes
        controller=human
        team_name=1
        team_lock=yes
        color_lock={COLOR_LOCK}
        gold_lock=yes
        income_lock=yes
        fog=yes
        shroud=yes
        gold=200
        village_gold={VILLAGE_GOLD}
        share_maps=yes
        share_view=yes
        id="Commander" # Custom Campaign Compatability
    [/side]

    [event]
        name=victory

        # store initial player game setup data in the opening scenario
        # var player is never cleared, as it's needed throughout the campaign
        [store_side]
            side={SIDE}
            variable=player{SIDE}
        [/store_side]

        # if aoh_type_era checked, add 100 gold & 4 income to player side
        [if]
            {VARIABLE_CONDITIONAL random_campaign.aoh_type_era equals yes}
            [then]
                {VARIABLE_OP player{SIDE}.gold add 100}
                {VARIABLE_OP player{SIDE}.income add 4}
            [/then]
        [/if]

        [store_turns]
            variable=player{SIDE}.turn_limit
        [/store_turns]

        # use lua to extract ai recruitment_pattern and add it
        {VARIABLE current_side {SIDE}}
        [lua]
            code=<<
                local i = wesnoth.get_variable("current_side")
                wesnoth.set_variable("lua_store", wesnoth.sides[i].__cfg)
            >>
        [/lua]
        {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
        {VARIABLE player{SIDE}.recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
        {CLEAR_VARIABLE current_side}

        # we only want the change from normal income, so account for that
        {VARIABLE_OP player{SIDE}.income sub 2}

        # Custom Campaign Compatability
        [if]
            {VARIABLE_CONDITIONAL cc_chosen_army.id equals $null}
            [then]
                # store leader, to recreate later
                [store_unit]
                    variable=temp_unit
                    kill=yes
                    [filter]
                        side={SIDE}
                    [/filter]
                [/store_unit]
                # Copy only the info we need to the player var
                {VARIABLE player{SIDE}.leader $temp_unit.type}
                {VARIABLE player{SIDE}.gender $temp_unit.gender}
                {CLEAR_VARIABLE temp_unit}

                # make sure shroud is on,
                # as creating unit will cause map to be seen if it is off.
                [modify_side]
                    side={SIDE}
                    fog=yes
                    shroud=yes
                [/modify_side]

                # Recreate unit now so powerful trait can be given
                [unit]
                    side={SIDE}
                    id="Commander" # Custom Campaign Compatability
                    role="Leader"  # Custom Campaign Compatability
                    type=$player{SIDE}.leader
                    name=$player{SIDE}.name
                    gender=$player{SIDE}.gender
                    canrecruit=yes
                    placement=map,leader
                    # All leaders get powerful trait
                    [modifications]
                        {RC_TRAIT_POWERFUL}
                    [/modifications]
                [/unit]
                {RC_QUICK_4MP_LEADERS {SIDE}}
            [/then]
            [else]
                # Suppress Custom Campaign from running in future scenarios
                # Custom Campaign checks for this var
                {VARIABLE random_campaign.custom_campaign true}
            [/else]
        [/if]
    [/event]
#enddef

#define RC_ENEMY_SIDE_STORE SIDE
    # The enemy sides needed throughout the campaign
    # are made in the intial scenario.
    # This macro stores all the needed information into var enemy
    #
    # extract data from side {SIDE} to side 9
    # then merge difficulty options into the stored sides
    # gather all data necessary to recreate a side in
    # future scenarios
    #
    # This is written this way so it can be used for the enemy sides
    # in both the 1p and 3p versions.

    [event]
        name=victory

        # Convert option difficulty slider
        # into enemy starting gold & income levels.

        [switch]
            variable=random_campaign.difficulty
            [case]
                value=1 # Easy
                {VARIABLE faction_values.gold 150}
                {VARIABLE faction_values.income 0}
            [/case]
            [case]
                value=2 # Normal
                {VARIABLE faction_values.gold 175}
                {VARIABLE faction_values.income 2}
            [/case]
            [case]
                value=3 # Hard
                {VARIABLE faction_values.gold 200}
                {VARIABLE faction_values.income 4}
            [/case]
            [case]
                value=4 # Nightmare
                {VARIABLE faction_values.gold 225}
                {VARIABLE faction_values.income 6}
            [/case]
        [/switch]

        # if Aoh Era checked, add 100 gold & 6 income to starting enemy
        [if]
            {VARIABLE_CONDITIONAL random_campaign.aoh_type_era equals yes}
            [then]
                {VARIABLE_OP faction_values.gold add 100}
                {VARIABLE_OP faction_values.income add 6}
            [/then]
        [/if]

        # set income to account for a default of 2 in future scenarios
        {VARIABLE_OP faction_values.income sub 2}

        {VARIABLE current_side {SIDE}}
        {VARIABLE max_side 9}
        {VARIABLE i 0}
        # store each faction side needed and modify some of the values
        [while]
            {VARIABLE_CONDITIONAL current_side less_than_equal_to $max_side}
            [do]
                # store faction side
                [store_side]
                    side=$current_side
                    variable=faction[$i]
                [/store_side]

                # store faction leader
                [store_unit]
                    variable=temp_unit
                    [filter]
                        side=$current_side
                    [/filter]
                [/store_unit]
                # Copy only the info we need to the faction var
                {VARIABLE faction[$i].leader $temp_unit.type}
                {VARIABLE faction[$i].gender $temp_unit.gender}
                {CLEAR_VARIABLE temp_unit}

                # Adjust enemy color to complement player's chosen color
                # Only adjust for mp 1 player, not 3 player.
                [if]
                    {VARIABLE_CONDITIONAL random_campaign.scenario_prefix equals "RC_1P_"}
                    [then]
                        {RC_COLOR_ADJUST $player1.color temp_color}
                        {VARIABLE faction[$i].color $temp_color}
                        {CLEAR_VARIABLE temp_color}
                    [/then]
                [/if]

                # modify the gold & income to chosen settings
                {VARIABLE faction[$i].gold $faction_values.gold}
                {VARIABLE faction[$i].income $faction_values.income}

                # use lua to extract ai recruitment_pattern and add it
                [lua]
                    code=<<
                        local j = wesnoth.get_variable("current_side")
                        wesnoth.set_variable("lua_store", wesnoth.sides[j].__cfg)
                    >>
                [/lua]
                {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
                {VARIABLE faction[$i].recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
                {CLEAR_VARIABLE index,lua_store}

                {VARIABLE_OP i add 1}
                {VARIABLE_OP current_side add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE i,current_side,max_side,faction_values}

        # Go through each of the sides, Copy first into new array
        # check if second is same as first by recruit, if not copy into second slot
        # then check third. Continue for fourth. Go backwards through side array.
        # It's just simpler to ignore duplicate leaders if recruit is duplicate.
        # Rough odds of a 6 faction era having a faction repeat are 1 in ????.

        # add first enemy
        [set_variables]
            name=enemy[0]
            mode=replace
            to_variable=faction[8]
        [/set_variables]
        {VARIABLE i 7}
        {VARIABLE j 1}
        [while]
            {VARIABLE_CONDITIONAL i greater_than_equal_to 0}
            {VARIABLE_CONDITIONAL j less_than 4}
            [do]
                {FOREACH enemy k}
                    [if]
                        {VARIABLE_CONDITIONAL faction[$i].recruit equals $enemy[$k].recruit}
                        [then]
                            {VARIABLE already_present "yes"}
                        [/then]
                    [/if]
                {NEXT k}
                [if]
                    {VARIABLE_CONDITIONAL already_present equals $null}
                    [then]
                        [set_variables]
                            name=enemy[$j]
                            mode=replace
                            to_variable=faction[$i]
                        [/set_variables]
                        {VARIABLE_OP j add 1}
                    [/then]
                    [else]
                        {VARIABLE_OP i sub 1}
                    [/else]
                [/if]
                {CLEAR_VARIABLE already_present}
            [/do]
        [/while]
        # check if we filled all four enemy slots, if not, gotta use something.
        [if]
            {VARIABLE_CONDITIONAL j less_than 4}
            [then]
                [while]
                    {VARIABLE_CONDITIONAL j less_than 4}
                    [do]
                        [set_variables]
                            name=enemy[$j]
                            mode=replace
                            to_variable=faction[$m]
                        [/set_variables]
                        {VARIABLE_OP m add 1}
                        {VARIABLE_OP j add 1}
                    [/do]
                [/while]
            [/then]
        [/if]
        {CLEAR_VARIABLE i,j,m,faction}

        # Adjust enemy gold & income for each scenario
        {VARIABLE_OP enemy[0].gold add 125}
        {VARIABLE_OP enemy[0].income add 6}
        {VARIABLE_OP enemy[0].income multiply 2.5}
        {VARIABLE_OP enemy[0].income sub 2}
        {VARIABLE_OP enemy[1].gold add 50}
        {VARIABLE_OP enemy[1].income add 4}
        {VARIABLE_OP enemy[2].gold add 25}
        {VARIABLE_OP enemy[2].income add 2}
    [/event]
#enddef

# PLAYER AND ENEMY MACROS FOR SCENARIOS

#define RC_PLAYER_SIDE SIDE
    [side]
        side={SIDE}
        save_id="P{SIDE}"
        persistent=yes
        controller=human
        team_name=1
        share_maps=yes
        share_view=yes
        id="Commander" # Custom Campaign Compatability
        type=Peasant   # If no leader is found
    [/side]

    # Unpack player side data out of a var
    [event]
        name=prestart

        # Check if side is being used, if not, skip everything
        [if]
            {VARIABLE_CONDITIONAL player{SIDE}.controller not_equals null}
            [then]
                # Restore the player's side
                [modify_side]
                    side={SIDE}
                    color=$player{SIDE}.color
                    village_gold=$player{SIDE}.village_gold
                    gold=$player{SIDE}.gold
                    income=$player{SIDE}.income
                    fog=$player{SIDE}.fog
                    shroud=$player{SIDE}.shroud
                    [ai]
                        recruitment_pattern=$player{SIDE}.recruitment_pattern
                    [/ai]
                [/modify_side]

                # Custom Campaign Compatability
                [if]
                    {VARIABLE_CONDITIONAL custom_campaign.modification equals yes}
                    [then]
                        [lua]
                            [args]
                                side={SIDE}
                                flag=$cc_chosen_army.flag
                                flag_icon=$cc_chosen_army.flag_icon
                                starting_recall=$cc_chosen_army.starting_recall
                            [/args]
                            code=<<
								local args = ...
								-- recall any leaders, expendable leaders, and heroes
								local loc = wesnoth.get_starting_location(args.side)
								local recall_list = wesnoth.get_recall_units({ side=args.side })
								for u = 1, #recall_list do
									if recall_list[u].canrecruit == true or recall_list[u].role == "Hero" then
										local id = recall_list[u].id
										wesnoth.wml_actions.recall({ x=loc[1], y=loc[2], id=id, show="no", fire_event="no" })
									end
								end
								-- additional recalls
								if args.starting_recall == -1 then
									-- recall all loyal units
									local recall_list = wesnoth.get_recall_units({ side=side })
									for i = 1, #recall_list do
										wesnoth.wml_actions.recall({ x=loc[1], y=loc[2], { "filter_wml", { upkeep="loyal" }}, show="no", fire_event="no" })
									end
								elseif args.starting_recall > 0 then
									-- sort units by value and recall the specified number
									-- sort order: loyal, level, least XP to levelup
									local recall_list = wesnoth.get_recall_units({ side=side })
									local function unit_value_sort(u1, u2)				
										if u1.__cfg.upkeep == u2.__cfg.upkeep then
											if u1.__cfg.level == u2.__cfg.level then
												return u1.max_experience - u1.experience < u2.max_experience - u2.experience
											else
												return u1.__cfg.level > u2.__cfg.level
											end
										else
											return u1.__cfg.upkeep > u2.__cfg.upkeep
										end
									end
									table.sort(recall_list, unit_value_sort)
									for u = 1, args.starting_recall do
										local id = recall_list[u].id
										wesnoth.wml_actions.recall({ x=loc[1], y=loc[2], id=id, show="no", fire_event="no" })
									end
								end
								-- set flag
								wml_actions.modify_side({ side=args.side, flag=args.flag, flag_icon=args.flag_icon })
							>>
                        [/lua]
                    [/then]
                [/if]

                [if] # Check if last scenario
                    {VARIABLE_CONDITIONAL scenario not_equals 4}
                    [then]
                        [modify_turns]
                            value=$player{SIDE}.turn_limit
                        [/modify_turns]
                    [/then]
                    [else]
                        # default is already -1, change var for objectives check
                        {VARIABLE player{SIDE}.turn_limit -1}
                        # increase player gold & income for last scenario.
                        [gold]
                            amount=50
                            side={SIDE}
                        [/gold]
                        [modify_side]
                            side={SIDE}
                            income=4
                        [/modify_side]
                    [/else]
                [/if]

                # show the player the objectives for the map
                [if]
                    {VARIABLE_CONDITIONAL custom_campaign.modification equals $null}
                    [then]
                        [objectives]
                            side={SIDE}
                            [objective]
                                description= _ "Defeat enemy leader"
                                condition=win
                            [/objective]
                            [objective]
                                description= _ "Death of your leader"
                                condition=lose
                            [/objective]
                            [objective]
                                description= _ "Turns run out"
                                condition=lose
                                show_turn_counter=yes
                                [show_if]
                                    {VARIABLE_CONDITIONAL player{SIDE}.turn_limit not_equals -1}
                                [/show_if]
                            [/objective]
                        [/objectives]
                    [/then]
                    [else]
                        # Custom Campaign Comptability
                        [lua]
                            [args]
                                side={SIDE}
                            [/args]
                            code=<<
		                         _ = wesnoth.textdomain "wesnoth-Random_Campaign"
		                         local args = ...
									-- set objectives
									local objectives = { side=args.side }
									local c = 1
									objectives[c] = { "objective", { condition="win", description=_"Defeat enemy leader" } }
									c = c + 1
									local units = wesnoth.get_units({ side=args.side })
									for u = 1, #units do
										if units[u].id == "Commander" and units[u].role == "Leader" then
											objectives[c] = { "objective", { condition="lose", description=_"Death of " .. units[u].name } }
											c = c + 1
										end
									end
									for u = 1, #units do
										if units[u].role == "Leader" and units[u].id ~= "Commander" then
											objectives[c] = { "objective", { condition="lose", description=_"Death of " .. units[u].name } }
											c = c + 1
										end
									end
									if c == 2 then -- All leaders are expendable, therefore use this objective
										objectives[c] = { "objective", { condition="lose", description=_"Death of your leader(s)" } }
										c = c + 1
									end
									for u = 1, #units do
										if units[u].role == "Hero" then
											objectives[c] = { "objective", { condition="lose", description=_"Death of " .. units[u].name } }
											c = c + 1
										end
									end
									wesnoth.wml_actions.store_turns( { variable="custom_campaign.turn_limit" } )
									objectives[c] = { "objective", { condition="lose", show_turn_counter="yes", description=_"Turns run out",
										{ "show_if", { { "variable", { name="custom_campaign.turn_limit", not_equals="-1" } } } }   } }
									wesnoth.wml_actions.objectives(objectives)
		                     >>
                        [/lua]
                    [/else]
                [/if]
            [/then]
        [/if]
    [/event]

    # Custom Campaign Compatibility
    [event]
        name=die
        first_time_only=no

        [lua]
            code=<<
				-- 1. Check if a Leader or Hero has died. If so, end the level in defeat.
				   -- a. Filter for role="Leader,Hero"
				   -- b. End the level.
				local u = wesnoth.get_variable("unit")
				if u.role == "Leader" or u.role == "Hero" then
					wesnoth.wml_actions.endlevel({ result="defeat" })
				end
				-- 2. If an Expendable Leader that is the Commander has died, try to reassign Commander status to
				   -- first to another Expendable Leader, second to a Leader. (just get the first one that matches the filter
				   -- in either case, and give that one id="Commander".) Assume that since the player made the
				   -- Commander an Expendable one, he'd like to reassign Commander status to another Expendable Leader if possible.
				   -- a. check if id="Commander" and role="Expendable Leader"
				   -- b. Filter for role="Expendable Leader" then for role="Leader"
				if u.id == "Commander" and u.role == "Expendable Leader" then
					local leaders = wesnoth.get_units({ side=u.side, canrecruit=true, { "not", { id="Commander" }} })
					if next(leaders) then
						table.sort(leaders, function (u1,u2) return (u1.role < u2.role) end)
						local new = leaders[1].__cfg
						new.id = "Commander"
						wesnoth.extract_unit(leaders[1])
						wesnoth.put_unit(new)
					end
				end
            >>
        [/lua]
    [/event]

    [event]
        name=victory

        # show the player the whole map
        [modify_side]
            side={SIDE}
            fog=no
            shroud=no
        [/modify_side]
    [/event]
#enddef

#define RC_ENEMY_SIDE SIDE
    # Two parts to a side, the side tag,
    # and the faction.

    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        no_leader=yes
        team_name=2
    [/side]

    [event]
        name=prestart
        # Create an enemy side from the enemy array

        # Get the length of the array, take info
        # from the last slot of the array,
        # then delete the last slot.

        {VARIABLE slot $enemy.length}
        {VARIABLE_OP slot sub 1}

        # Make a new unit instead of unstoring old one
        # so unit will have a proper name for the unit
        # also so initial experience_modifier is wiped
        # as experience_modifier doesn't persist
        [unit]
            side={SIDE}
            id=Enemy Commander
            type=$enemy[$slot].leader
            canrecruit=yes
            gender=$enemy[$slot].gender
            placement=map,leader
            # All leaders get powerful trait
            [modifications]
                {RC_TRAIT_POWERFUL}
            [/modifications]
        [/unit]
        {RC_QUICK_4MP_LEADERS {SIDE}}

        # restore the rest of the relevant data for the side
        [modify_side]
            side={SIDE}
            color=$enemy[$slot].color
            gold=$enemy[$slot].gold
            income=$enemy[$slot].income
            village_gold=$enemy[$slot].village_gold
            fog=$enemy[$slot].fog
            shroud=$enemy[$slot].shroud
            [ai]
                recruitment_pattern=$enemy[$slot].recruitment_pattern
            [/ai]
        [/modify_side]
        [set_recruit]
            side={SIDE}
            recruit=$enemy[$slot].recruit
        [/set_recruit]

        # clear the array slot we just used
        {CLEAR_VARIABLE enemy[$slot]}
        {CLEAR_VARIABLE slot}
    [/event]
#enddef

#define RC_ENEMY_GOLD_ADJUST_MP SIDE
    [event]
        name=prestart
        # Count number of players
        # Number is used in 3p campaign to determine
        # how much gold & income the enemy side should have.
        [store_unit]
            variable=player_count
            [filter]
                side=1,2,3
                [and]
                    canrecruit=yes
                [/and]
            [/filter]
        [/store_unit]

        [store_side]
            side={SIDE}
            variable=enemy_temp
        [/store_side]

        # var scenario set in next_scenario.cfg
        # gold adjust formula
        {VARIABLE_OP enemy_temp.gold multiply $player_count.length}

        # income adjust formula
        {VARIABLE_OP enemy_temp.income multiply $player_count.length}

        # account for default of 2 income
        {VARIABLE_OP enemy_temp.income sub 2}

        # change gold & income values
        [modify_side]
            side={SIDE}
            gold=$enemy_temp.gold
            income=$enemy_temp.income
        [/modify_side]

        {CLEAR_VARIABLE enemy_temp,player_count}
    [/event]
#enddef
