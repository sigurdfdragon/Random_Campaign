#textdomain wesnoth-Random_Campaign

# SETUP SCENARIO MACROS

#define RC_ENEMY_SIDE_GOLD_INCOME SIDE
    [side]
        side={SIDE}
        allow_player=yes
        persistent=no
        controller=ai
        team_name=2
        team_lock=yes
        color_lock=yes
        fog=yes
        shroud=yes
    [/side]
#enddef

#define RC_ENEMY_SIDE_START SIDE
    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        hidden=yes
        team_name=2
        fog=yes
        shroud=yes
    [/side]
#enddef

#define RC_PLAYER_SIDE_START SIDE
    [side]
        side={SIDE}
        id="Player{SIDE}Leader"
        save_id="P{SIDE}"
        persistent=yes
        controller=human
        team_name=1
        team_lock=yes
        color_lock=yes
        fog=yes
        shroud=yes
        canrecruit=yes
    [/side]

    [event]
        name=victory
        
        # store initial player game setup data in the opening scenario
        # var player is never cleared, as it's needed throughout the campaign
        [store_side]
            side={SIDE}
            variable=player[{SIDE}]
        [/store_side]
        
        # use lua to extract ai recruitment_pattern and add it
        {VARIABLE current_side {SIDE}}
        [lua]
            code=<<
                local i = wesnoth.get_variable("current_side")
                wesnoth.set_variable("lua_store", wesnoth.sides[i].__cfg)
            >>
        [/lua]
        {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
        {VARIABLE player[{SIDE}].recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
        {CLEAR_VARIABLE current_side}

        # we only want the change from normal income, so account for that
        {VARIABLE_OP player[{SIDE}].income sub 2}

        # set gold_bonus to half of starting gold
        {VARIABLE player[{SIDE}].gold_bonus $player[{SIDE}].gold}
        {VARIABLE_OP player[{SIDE}].gold_bonus divide 2}

        # store leader, to recreate later
        [store_unit]
            variable=player[{SIDE}].leader
            kill=no
            [filter]
                side={SIDE}
            [/filter]
        [/store_unit]        
    [/event]
#enddef

#define RC_ENEMY_SIDE_STORE SIDE GOLD
    # The enemy sides needed throughout the campaign
    # are made in the intial scenario.
    # This macro stores all the needed information into var enemy
    #
    # extract data from side {SIDE} to side 9
    # then merge data from side {GOLD} into the stored sides
    # gather all data necessary to recreate a side in
    # future scenarios
    #
    # This is written this way so it can be used for the enemy sides
    # in both the 1p and 3p versions.
    [event]
        name=victory
        
        {VARIABLE current_side {SIDE}}
        {VARIABLE max_side 9}
        {VARIABLE i 0}
        
        # store enemy gold & income settings
        # from the configurable side
        [store_side]
            side={GOLD}
            variable=enemy_values
        [/store_side]
        # set income to account for a default of 2 in future scenarios
        {VARIABLE_OP enemy_values.income sub 2}
        
        # store each enemy side needed and modify some of the values
        [while]
            {VARIABLE_CONDITIONAL current_side less_than_equal_to $max_side}
            [do]
                # store enemy side
                [store_side]
                    side=$current_side
                    variable=enemy[$i]
                [/store_side]
                
                # store enemy leader
                [store_unit]
                    variable=enemy[$i].leader
                    [filter]
                        side=$current_side
                    [/filter]
                [/store_unit]
                
                # modify the gold & income to chosen settings
                {VARIABLE enemy[$i].income $enemy_values.income}
                {VARIABLE enemy[$i].gold $enemy_values.gold}
                
                # use lua to extract ai recruitment_pattern and add it
                [lua]
                    code=<<
                        local j = wesnoth.get_variable("current_side")
                        wesnoth.set_variable("lua_store", wesnoth.sides[j].__cfg)
                    >>
                [/lua]
                {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
                {VARIABLE enemy[$i].recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
                {CLEAR_VARIABLE index,lua_store}
                
                {VARIABLE_OP i add 1}
                {VARIABLE_OP current_side add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE i,current_side,max_side,enemy_values}
    [/event]
#enddef

# PLAYER AND ENEMY MACROS FOR SCENARIOS

#define RC_PLAYER_SIDE SIDE
    [side]
        side={SIDE}
        id="Player{SIDE}"
        save_id="P{SIDE}"
        persistent=1
        controller=human
        team_name=1
        no_leader=yes
        canrecruit=yes
    [/side]
    
    # Unpack the player side out of a var
    [event]
        name=prestart
        
        # Check if side is being used, if not, skip everything
        [if]
            {VARIABLE_CONDITIONAL player[{SIDE}].controller not_equals null}
            [then]
                # Restore the player's side

                # Restore the custom recall list
                {FOREACH side_{SIDE}_recall i}
                    [unstore_unit]
                        variable=side_{SIDE}_recall[$i]
                        x,y=recall,recall
                    [/unstore_unit]
                {NEXT i}
                {CLEAR_VARIABLE side_{SIDE}_recall}

                # Get the true leader back
                [if]
                    {VARIABLE_CONDITIONAL scenario equals 1} # scenario set in next_scenario.cfg
                    [then]
                        # if 1st scenario,
                        # remake leader to nullify experience modifier setting
                        # as it can't persist anyway
                        [unit]
                            side={SIDE}
                            id=$player[{SIDE}].leader.id
                            type=$player[{SIDE}].leader.type
                            name=$player[{SIDE}].leader.name
                            gender=$player[{SIDE}].leader.gender
                            canrecruit=yes
                            placement=map,leader
                            # account for things like {QUICK_4MP_LEADER}
                            [insert_tag]
                                name=modifications
                                variable=player[{SIDE}].leader.modifications
                            [/insert_tag]
                        [/unit]
                        # {CLEAR_VARIABLE player.leader}
                    [/then]
                    [else]
                        # Bring leader back from recall list
                        [store_starting_location]
                            variable=startpos
                            side={SIDE}
                        [/store_starting_location]
                        [recall]
                            canrecruit=yes
                            x,y=$startpos.x,$startpos.y
                            side={SIDE}
                            fire_event=no
                            show=no
                        [/recall]
                    [/else]
                [/if]
                {CLEAR_VARIABLE startpos}

                # restore the rest of the relevant data for the side
                [if]
                    {VARIABLE_CONDITIONAL scenario greater_than 1}
                    [then]
                        # increment starting gold by gold_bonus
                        {VARIABLE_OP player[{SIDE}].gold add $player[{SIDE}].gold_bonus}
                    [/then]
                [/if]
                [modify_side]
                    side={SIDE}
                    village_gold=$player[{SIDE}].village_gold
                    gold=$player[{SIDE}].gold
                    income=$player[{SIDE}].income
                    fog=$player[{SIDE}].fog
                    shroud=$player[{SIDE}].shroud
                    [ai]
                        recruitment_pattern=$player[{SIDE}].recruitment_pattern
                    [/ai]
                [/modify_side]
                [set_recruit]
                    side={SIDE}
                    recruit=$player[{SIDE}].recruit
                [/set_recruit]
                
                # show the player the objectives for the map
                [objectives]
                    side={SIDE}
                    [objective]
                        description="Defeat all enemy leaders"
                        condition=win
                    [/objective]
                    [objective]
                        description="Death of your leader"
                        condition=lose
                    [/objective]
                [/objectives]
            [/then]
        [/if]
    [/event]

    # At the end of the level, put the player side
    # back into a var
    [event]
        name=victory
        # Check if side is being used, if not, skip everything
        [if]
            {VARIABLE_CONDITIONAL player[{SIDE}].controller not_equals null}
            [then]
                # Hack 2b: Build a custom recall list
                # put everyone on player side on recall list
                [store_unit]
                    variable=side_{SIDE}_recall
                    kill=no
                    [filter]
                        side={SIDE}
                    [/filter]
                [/store_unit]
                
                # Heal, Clear Status, Reset attacks and move, set side to 1
                # This (hopefully) replicates everything that is done to restore a unit
                # upon victory. Must do it this way, as storing units occurs before
                # the victory restoring of all the players units.
                {FOREACH side_{SIDE}_recall i}
                    # alter underlying_id, ensuring uniqueness to prevent missing units
                    # if two units have the same underlying_id, one will not appear on the recall list
                    # formula is there because we have to start at 1 (not 0)
                    {VARIABLE side_{SIDE}_recall[$i].underlying_id "$($i+1)"}
                    
                    # while we're at it, change id to match
                    {VARIABLE side_{SIDE}_recall[$i].id "Army-{SIDE} Unit-$($i+1)"}
                                    
                    {CLEAR_VARIABLE side_{SIDE}_recall[$i|].status} # flush to catch all, gets recreated when unpacked
                    {VARIABLE side_{SIDE}_recall[$i|].hitpoints "$side_{SIDE}_recall[$i|].max_hitpoints"}
                    {VARIABLE side_{SIDE}_recall[$i|].moves "$side_{SIDE}_recall[$i|].max_moves"}
                    {VARIABLE side_{SIDE}_recall[$i|].attacks_left "$side_{SIDE}_recall[$i|].max_attacks"}
                    {VARIABLE side_{SIDE}_recall[$i|].goto_x 0}
                    {VARIABLE side_{SIDE}_recall[$i|].goto_y 0}
                {NEXT i}
                
                # show the player the whole map
                [modify_side]
                    side={SIDE}
                    fog=no
                    shroud=no
                [/modify_side]
            [/then]
        [/if]
    [/event]
#enddef

#define RC_ENEMY_SIDE SIDE
    # Two parts to a side, the side tag,
    # and the faction.
    
    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        no_leader=yes
        team_name=2
    [/side]

    [event]
        name=prestart
        # Create an enemy side from the enemy array
        
        # Get the length of the array, take info
        # from the last slot of the array,
        # then delete the last slot.
        
        {VARIABLE slot $enemy.length}
        {VARIABLE_OP slot sub 1}

        # Make a new unit instead of unstoring old one
        # so unit will have a proper name for the unit
        # also so initial experience_modifier is wiped
        # as experience_modifier doesn't persist
        [unit]
            side={SIDE}
            type=$enemy[$slot].leader.type
            canrecruit=yes
            gender=$enemy[$slot].leader.gender
            placement=map,leader
            # account for things like {QUICK_4MP_LEADER}
            [insert_tag]
                name=modifications
                variable=enemy[$slot].leader.modifications
            [/insert_tag]
        [/unit]

        # restore the rest of the relevant data for the side
        [modify_side]
            side={SIDE}
            gold=$enemy[$slot].gold
            income=$enemy[$slot].income
            village_gold=$enemy[$slot].village_gold
            fog=$enemy[$slot].fog
            shroud=$enemy[$slot].shroud
            [ai]
                recruitment_pattern=$enemy[$slot].recruitment_pattern
            [/ai]
        [/modify_side]
        [set_recruit]
            side={SIDE}
            recruit=$enemy[$slot].recruit
        [/set_recruit]
        
        # clear the array slot we just used
        {CLEAR_VARIABLE enemy[$slot]}
        {CLEAR_VARIABLE slot}
    [/event]
#enddef

#define RC_ENEMY_GOLD_ADJUST_MP SIDE
    [event]
        name=prestart
        
        # Code for player count needed for MP version
        # need to get an accurate count of how many player slots are actually filled
        [store_unit]
            variable=players
            [filter]
                side=1,2,3
            [/filter]
        [/store_unit]

        # clean up, don't need saves to get any more bloated than necessary
        {VARIABLE temp $players.length}
        {CLEAR_VARIABLE players}
        {VARIABLE players $temp}
        {CLEAR_VARIABLE temp}
        
        [store_side]
            side={SIDE}
            variable=enemy_temp
        [/store_side]
        
        # var scenario set in next_scenario.cfg
        # gold adjust formula
        {VARIABLE_OP enemy_temp.gold multiply $players}
        {VARIABLE_OP enemy_temp.gold multiply $scenario}
        
        # income adjust formula
        {VARIABLE_OP enemy_temp.income multiply $players}
        {VARIABLE_OP enemy_temp.income multiply $scenario}
        # account for default of 2 income
        {VARIABLE_OP enemy_temp.income sub 2}
        
        # change gold & income values
        [modify_side]
            side={SIDE}
            gold=$enemy_temp.gold
            income=$enemy_temp.income
        [/modify_side]
        
        {CLEAR_VARIABLE enemy_temp,players}
    [/event]
#enddef
