#textdomain wesnoth-Random_Campaign

# SETUP SCENARIO MACROS

#define RC_ENEMY_SIDE_GOLD_INCOME SIDE
    [side]
        side={SIDE}
        allow_player=yes
        persistent=no
        controller=ai
        team_name=2
        team_lock=yes
        color_lock=yes
		gold_lock=yes
		income_lock=yes
        fog=yes
        shroud=no
		gold=200
		village_gold=1
    [/side]
#enddef

#define RC_ENEMY_SIDE_START SIDE
    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        hidden=yes
        team_name=2
        fog=yes
        shroud=no
		gold=200
		village_gold=1
    [/side]
#enddef

#define RC_PLAYER_SIDE_START SIDE
    [side]
        side={SIDE}
		id="Main Leader" # Custom Campaign Compatability
        save_id="P{SIDE}"
        persistent=yes
        controller=human
        team_name=1
        team_lock=yes
        color_lock=yes
		gold_lock=yes
		income_lock=yes
        fog=yes
        shroud=no
        canrecruit=yes
		gold=200
		village_gold=1
		share_maps=yes
		share_view=yes
    [/side]

    [event]
        name=victory
        
        # store initial player game setup data in the opening scenario
        # var player is never cleared, as it's needed throughout the campaign
        [store_side]
            side={SIDE}
            variable=player[{SIDE}]
        [/store_side]
		
		[store_turns]
			variable=player[{SIDE}].turn_limit
		[/store_turns]
        
        # use lua to extract ai recruitment_pattern and add it
        {VARIABLE current_side {SIDE}}
        [lua]
            code=<<
                local i = wesnoth.get_variable("current_side")
                wesnoth.set_variable("lua_store", wesnoth.sides[i].__cfg)
            >>
        [/lua]
        {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
        {VARIABLE player[{SIDE}].recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
        {CLEAR_VARIABLE current_side}

        # we only want the change from normal income, so account for that
        {VARIABLE_OP player[{SIDE}].income sub 2}

        # store leader, to recreate later
        [store_unit]
            variable=player[{SIDE}].leader
            kill=no
            [filter]
                side={SIDE}
            [/filter]
        [/store_unit]
		
		# make sure shroud is on, as pausing at trait selection will make map appear
		[modify_side]
			side={SIDE}
			fog=yes
			shroud=yes
		[/modify_side]
    [/event]
#enddef

#define RC_LEADER_TRAITS_SELECTION SIDE
	[event]
		name=victory
		
		# Choose three traits for leader
		[set_variables]
			name=trait_array
			[value]
				{TRAIT_STRONG}
				{TRAIT_DEXTROUS}
				{TRAIT_QUICK}
				{TRAIT_INTELLIGENT}
				{TRAIT_RESILIENT}
				{TRAIT_HEALTHY}
				{TRAIT_FEARLESS}
			[/value]
		[/set_variables]

		{FOREACH trait_array.trait i}
			[if]
				{VARIABLE_CONDITIONAL player[{SIDE}].leader.gender equals female}
				[then]
					{VARIABLE trait_choice[$i].message $trait_array.trait[$i].female_name}
				[/then]
				[else]
					{VARIABLE trait_choice[$i].message $trait_array.trait[$i].male_name}
				[/else]
			[/if]
			[set_variables]
				name=trait_choice[$i].command
				[value]
					{VARIABLE choice $i}
				[/value]
			[/set_variables]	
		{NEXT i}

		{VARIABLE i 0}
		[while]
			{VARIABLE_CONDITIONAL i less_than 3}
			[do]
				[message]
					speaker=narrator
					message=_"Select three traits for your leader:"
					[insert_tag]
						name=option
						variable=trait_choice
					[/insert_tag]
				[/message]
				
				# choice is recorded in an array, and the option is turned gold
				# and deactivated for future choices
				{VARIABLE chosen_traits.trait[$i] $choice}
				[set_variables]
					name=trait_choice[$choice].command
					mode=replace
					[value]
						{VARIABLE choice "chosen"}
					[/value]
				[/set_variables]
				[if]
					{VARIABLE_CONDITIONAL choice not_equals "chosen"}
					[then]
						[if]
							{VARIABLE_CONDITIONAL player[{SIDE}].leader.gender equals female}
							[then]
								{VARIABLE trait_choice[$choice].message "<span color='#BCB088'>$trait_array.trait[$choice].female_name</span>"}
							[/then]
							[else]
								{VARIABLE trait_choice[$choice].message "<span color='#BCB088'>$trait_array.trait[$choice].male_name</span>"}
							[/else]
						[/if]
						{VARIABLE_OP i add 1}
					[/then]
				[/if]
			[/do]
		[/while]
		{CLEAR_VARIABLE i}
		
		{FOREACH chosen_traits.trait i}
			[set_variables]
				name=player[{SIDE}].leader.modifications.trait[i]
				mode=replace
				to_variable=trait_array.trait[$chosen_traits.trait[i]]
			[/set_variables]
		{NEXT i}
		{CLEAR_VARIABLE trait_array,chosen_traits,trait_choice,choice}
	[/event]
#enddef

#define RC_ENEMY_SIDE_STORE SIDE GOLD
    # The enemy sides needed throughout the campaign
    # are made in the intial scenario.
    # This macro stores all the needed information into var enemy
    #
    # extract data from side {SIDE} to side 9
    # then merge data from side {GOLD} into the stored sides
    # gather all data necessary to recreate a side in
    # future scenarios
    #
    # This is written this way so it can be used for the enemy sides
    # in both the 1p and 3p versions.

    [event]
        name=victory
        
		{VARIABLE current_side {SIDE}}
        {VARIABLE max_side 9}
        {VARIABLE i 0}
        
        # store faction gold & income settings
        # from the configurable side
        [store_side]
            side={GOLD}
            variable=faction_values
        [/store_side]
        # set income to account for a default of 2 in future scenarios
        {VARIABLE_OP faction_values.income sub 2}
        
        # store each faction side needed and modify some of the values
        [while]
            {VARIABLE_CONDITIONAL current_side less_than_equal_to $max_side}
            [do]
                # store faction side
                [store_side]
                    side=$current_side
                    variable=faction[$i]
                [/store_side]
                
                # store faction leader
                [store_unit]
                    variable=faction[$i].leader
                    [filter]
                        side=$current_side
                    [/filter]
                [/store_unit]
                
                # modify the gold & income to chosen settings
                {VARIABLE faction[$i].income $faction_values.income}
                {VARIABLE faction[$i].gold $faction_values.gold}
                
                # use lua to extract ai recruitment_pattern and add it
                [lua]
                    code=<<
                        local j = wesnoth.get_variable("current_side")
                        wesnoth.set_variable("lua_store", wesnoth.sides[j].__cfg)
                    >>
                [/lua]
                {LOOKUP_INDEX lua_store.ai.aspect id "recruitment_pattern" index}
                {VARIABLE faction[$i].recruitment_pattern "$lua_store.ai.aspect[$index].facet.value"}
                {CLEAR_VARIABLE index,lua_store}
                
                {VARIABLE_OP i add 1}
                {VARIABLE_OP current_side add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE i,current_side,max_side,faction_values}
		
		# Go through each of the sides, Copy first into new array
		# check if second is same as first by recruit, if not copy into second slot
		# then check third. Go backwards through side array.
		# It's just simpler to ignore duplicate leaders if recruit is duplicate.
		# Rough odds of a 6 faction era having a faction repeat are 1 in 6500.
		# This code could probably be simpler.
		
		# add first enemy
		[set_variables]
			name=enemy[0]
			mode=replace
			to_variable=faction[8]
		[/set_variables]
		
		# add second enemy
		{VARIABLE j 8}
		[while]
			{VARIABLE_CONDITIONAL j greater_than_equal_to 0}
			{VARIABLE_CONDITIONAL j not_equals 10}
			[do]
				[if]
					{VARIABLE_CONDITIONAL enemy[0].recruit not_equals $faction[$j].recruit}
					{VARIABLE_CONDITIONAL enemy[0].leader.type not_equals $null}
					[then]
						[set_variables]
							name=enemy[1]
							mode=replace
							to_variable=faction[$j]
						[/set_variables]
						{VARIABLE j 10}
					[/then]
					[else]
						{VARIABLE_OP j sub 1}
					[/else]
				[/if]
			[/do]
		[/while]
		[if]
			{VARIABLE_CONDITIONAL j not_equals 10}
			[then]
				[set_variables]
					name=enemy[1]
					mode=replace
					to_variable=faction[7]
				[/set_variables]
			[/then]
		[/if]
		
		# add third enemy
		{VARIABLE j 8}
		[while]
			{VARIABLE_CONDITIONAL j greater_than_equal_to 0}
			{VARIABLE_CONDITIONAL j not_equals 10}
			[do]
				[if]
					{VARIABLE_CONDITIONAL enemy[0].recruit not_equals $faction[$j].recruit}
					{VARIABLE_CONDITIONAL enemy[0].leader.type not_equals $null}
					{VARIABLE_CONDITIONAL enemy[1].recruit not_equals $faction[$j].recruit}
					{VARIABLE_CONDITIONAL enemy[1].leader.type not_equals $null}
					[then]
						[set_variables]
							name=enemy[2]
							mode=replace
							to_variable=faction[$j]
						[/set_variables]
						{VARIABLE j 10}
					[/then]
					[else]
						{VARIABLE_OP j sub 1}
					[/else]
				[/if]
			[/do]
		[/while]
		[if]
			{VARIABLE_CONDITIONAL j not_equals 10}
			[then]
				[set_variables]
					name=enemy[2]
					mode=replace
					to_variable=faction[6]
				[/set_variables]
			[/then]
		[/if]
		
		# Adjust enemy gold & income for each scenario
		{VARIABLE_OP enemy[0].gold add 50}
		{VARIABLE_OP enemy[0].income add 4}
		{VARIABLE_OP enemy[1].gold add 25}
		{VARIABLE_OP enemy[1].income add 2}
		
		{CLEAR_VARIABLE faction,j}
    [/event]
#enddef

# PLAYER AND ENEMY MACROS FOR SCENARIOS

#define RC_PLAYER_SIDE SIDE
    [side]
        side={SIDE}
		id="Main Leader" # Custom Campaign Compatability
        save_id="P{SIDE}"
        persistent=1
        controller=human
        team_name=1
        no_leader=yes
        canrecruit=yes
		share_maps=yes
		share_view=yes
    [/side]
    
    # Unpack the player side out of a var
    [event]
        name=prestart
        
        # Check if side is being used, if not, skip everything
        [if]
            {VARIABLE_CONDITIONAL player[{SIDE}].controller not_equals null}
            [then]
                # Restore the player's side

                # Restore the custom recall list
                {FOREACH side_{SIDE}_recall i}
                    [unstore_unit]
                        variable=side_{SIDE}_recall[$i]
                        x,y=recall,recall
                    [/unstore_unit]
                {NEXT i}
                {CLEAR_VARIABLE side_{SIDE}_recall}

                # Get the true leader back
                [if]
                    {VARIABLE_CONDITIONAL scenario equals 1} # scenario set in next_scenario.cfg
                    [then]
                        # if 1st scenario,
                        # remake leader to nullify experience modifier setting
                        # as it can't persist anyway
                        [unit]
                            side={SIDE}
							id="Main Leader" # Custom Campaign Compatability
							role="Leader"    # Custom Campaign Compatability
                            type=$player[{SIDE}].leader.type
                            name=$player[{SIDE}].leader.name
                            gender=$player[{SIDE}].leader.gender
                            canrecruit=yes
                            placement=map,leader
                            # account for things like {QUICK_4MP_LEADER}
                            [insert_tag]
                                name=modifications
                                variable=player[{SIDE}].leader.modifications
                            [/insert_tag]
                        [/unit]
                        # {CLEAR_VARIABLE player.leader}
                    [/then]
                    [else]
                        # Bring leader back from recall list
                        [store_starting_location]
                            variable=startpos
                            side={SIDE}
                        [/store_starting_location]
                        [recall]
                            canrecruit=yes
                            x,y=$startpos.x,$startpos.y
                            side={SIDE}
                            fire_event=no
                            show=no
                        [/recall]
                    [/else]
                [/if]
                {CLEAR_VARIABLE startpos}

                # restore the rest of the relevant data for the side
                [if]
                    {VARIABLE_CONDITIONAL scenario greater_than 1}
                    [then]
                        # increment starting gold by gold_bonus
                        {VARIABLE_OP player[{SIDE}].gold add $player[{SIDE}].gold_bonus}
                    [/then]
                [/if]
                [modify_side]
                    side={SIDE}
                    village_gold=$player[{SIDE}].village_gold
                    gold=$player[{SIDE}].gold
                    income=$player[{SIDE}].income
                    fog=$player[{SIDE}].fog
                    shroud=$player[{SIDE}].shroud
                    [ai]
                        recruitment_pattern=$player[{SIDE}].recruitment_pattern
                    [/ai]
                [/modify_side]
                [set_recruit]
                    side={SIDE}
                    recruit=$player[{SIDE}].recruit
                [/set_recruit]
				
				[modify_turns]
					value=$player[{SIDE}].turn_limit
				[/modify_turns]
                
                # show the player the objectives for the map
                [objectives]
                    side={SIDE}
                    [objective]
                        description="Defeat all enemy leaders"
                        condition=win
                    [/objective]
                    [objective]
                        description="Death of your leader"
                        condition=lose
                    [/objective]
                [/objectives]
            [/then]
        [/if]
    [/event]

    # At the end of the level, put the player side
    # back into a var
    [event]
        name=victory
        # Check if side is being used, if not, skip everything
        [if]
            {VARIABLE_CONDITIONAL player[{SIDE}].controller not_equals null}
            [then]
                # Hack 2b: Build a custom recall list
                # put everyone on player side on recall list
                [store_unit]
                    variable=side_{SIDE}_recall
                    kill=no
                    [filter]
                        side={SIDE}
                    [/filter]
                [/store_unit]
                
                # Heal, Clear Status, Reset attacks and move, set side to 1
                # This (hopefully) replicates everything that is done to restore a unit
                # upon victory. Must do it this way, as storing units occurs before
                # the victory restoring of all the players units.
                {FOREACH side_{SIDE}_recall i}
                    # clear underlying_id & id, ensuring uniqueness to prevent missing units
                    # if two units have the same underlying_id, one will not appear on the recall list
                    [if]
						{VARIABLE_CONDITIONAL army[$index].troop_list[$i].id equals "Main Leader"} # Custom Campaign Compatability
						[then]
							{CLEAR_VARIABLE army[$index].troop_list[$i].underlying_id} # only clear this
						[/then]
						[else] # clear both
							{CLEAR_VARIABLE army[$index].troop_list[$i].underlying_id}
							{CLEAR_VARIABLE army[$index].troop_list[$i].id}
						[/else]
					[/if]
                                    
                    {CLEAR_VARIABLE side_{SIDE}_recall[$i|].status} # flush to catch all, gets recreated when unpacked
                    {VARIABLE side_{SIDE}_recall[$i|].hitpoints "$side_{SIDE}_recall[$i|].max_hitpoints"}
                    {VARIABLE side_{SIDE}_recall[$i|].moves "$side_{SIDE}_recall[$i|].max_moves"}
                    {VARIABLE side_{SIDE}_recall[$i|].attacks_left "$side_{SIDE}_recall[$i|].max_attacks"}
                    {VARIABLE side_{SIDE}_recall[$i|].goto_x 0}
                    {VARIABLE side_{SIDE}_recall[$i|].goto_y 0}
                {NEXT i}
                
                # show the player the whole map
                [modify_side]
                    side={SIDE}
                    fog=no
                    shroud=no
                [/modify_side]
            [/then]
        [/if]
    [/event]
#enddef

#define RC_ENEMY_SIDE SIDE
    # Two parts to a side, the side tag,
    # and the faction.
    
    [side]
        side={SIDE}
        allow_player=no
        controller=ai
        no_leader=yes
        team_name=2
    [/side]

    [event]
        name=prestart
        # Create an enemy side from the enemy array
        
        # Get the length of the array, take info
        # from the last slot of the array,
        # then delete the last slot.
        
        {VARIABLE slot $enemy.length}
        {VARIABLE_OP slot sub 1}

        # Make a new unit instead of unstoring old one
        # so unit will have a proper name for the unit
        # also so initial experience_modifier is wiped
        # as experience_modifier doesn't persist
        [unit]
            side={SIDE}
            type=$enemy[$slot].leader.type
            canrecruit=yes
            gender=$enemy[$slot].leader.gender
            placement=map,leader
            # account for things like {QUICK_4MP_LEADER}
            [insert_tag]
                name=modifications
                variable=enemy[$slot].leader.modifications
            [/insert_tag]
        [/unit]

        # restore the rest of the relevant data for the side
        [modify_side]
            side={SIDE}
            gold=$enemy[$slot].gold
            income=$enemy[$slot].income
            village_gold=$enemy[$slot].village_gold
            fog=$enemy[$slot].fog
            shroud=$enemy[$slot].shroud
            [ai]
                recruitment_pattern=$enemy[$slot].recruitment_pattern
            [/ai]
        [/modify_side]
        [set_recruit]
            side={SIDE}
            recruit=$enemy[$slot].recruit
        [/set_recruit]
        
        # clear the array slot we just used
        {CLEAR_VARIABLE enemy[$slot]}
        {CLEAR_VARIABLE slot}
    [/event]
#enddef

#define RC_ENEMY_GOLD_ADJUST_MP SIDE
    [event]
        name=prestart
        
        # Code for player count needed for MP version
        # need to get an accurate count of how many player slots are actually filled
        [store_unit]
            variable=players
            [filter]
                side=1,2,3
            [/filter]
        [/store_unit]

        # clean up, don't need saves to get any more bloated than necessary
        {VARIABLE temp $players.length}
        {CLEAR_VARIABLE players}
        {VARIABLE players $temp}
        {CLEAR_VARIABLE temp}
        
        [store_side]
            side={SIDE}
            variable=enemy_temp
        [/store_side]
        
        # var scenario set in next_scenario.cfg
        # gold adjust formula
        {VARIABLE_OP enemy_temp.gold multiply $players}
        
        # income adjust formula
        {VARIABLE_OP enemy_temp.income multiply $players}
		
        # account for default of 2 income
        {VARIABLE_OP enemy_temp.income sub 2}
        
        # change gold & income values
        [modify_side]
            side={SIDE}
            gold=$enemy_temp.gold
            income=$enemy_temp.income
        [/modify_side]
        
        {CLEAR_VARIABLE enemy_temp,players}
    [/event]
#enddef
